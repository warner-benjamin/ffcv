

/*
 *****************************************************************************
 **       This file was autogenerated from a template  DO NOT EDIT!!!!      **
 **       Changes should be made to the original source (.src) file         **
 *****************************************************************************
 */

#line 1
/* -*- c -*- */
/*******************************************************************************
* Copyright (c) 2020, Intel Corporation
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright notice,
*       this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of Intel Corporation nor the names of its contributors
*       may be used to endorse or promote products derived from this software
*       without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*******************************************************************************/

#include "_ipp_util.h"


IppStatus
get_sizeof(
    IppDataType datatype,
    int * sizeof_datatype)
{
    IppStatus status = ippStsNoErr;
    switch (datatype)
    {
        case ipp1u:
        {
            *sizeof_datatype = sizeof(Ipp8u);
            break;
        }
        case ipp8s:
        {
            *sizeof_datatype = sizeof(Ipp8s);
            break;
        }
        case ipp8u:
        {
            *sizeof_datatype = sizeof(Ipp8u);
            break;
        }
        case ipp8sc:
        {
            *sizeof_datatype = sizeof(Ipp8sc);
            break;
        }
        case ipp16u:
        {
            *sizeof_datatype = sizeof(Ipp16u);
            break;
        }
        case ipp16uc:
        {
            *sizeof_datatype = sizeof(Ipp16uc);
            break;
        }
        case ipp16s:
        {
            *sizeof_datatype = sizeof(Ipp16s);
            break;
        }
        case ipp16sc:
        {
            *sizeof_datatype = sizeof(Ipp16sc);
            break;
        }
        case ipp32u:
        {
            *sizeof_datatype = sizeof(Ipp32u);
            break;
        }
        case ipp32s:
        {
            *sizeof_datatype = sizeof(Ipp32s);
            break;
        }
        case ipp32sc:
        {
            *sizeof_datatype = sizeof(Ipp32sc);
            break;
        }
        case ipp32f:
        {
            *sizeof_datatype = sizeof(Ipp32f);
            break;
        }
        case ipp32fc:
        {
            *sizeof_datatype = sizeof(Ipp32fc);
            break;
        }
        case ipp64u:
        {
            *sizeof_datatype = sizeof(Ipp64u);
            break;
        }
        case ipp64s:
        {
            *sizeof_datatype = sizeof(Ipp64s);
            break;
        }
        case ipp64sc:
        {
            *sizeof_datatype = sizeof(Ipp64sc);
            break;
        }
        case ipp64f:
        {
            *sizeof_datatype = sizeof(Ipp64f);
            break;
        }
        case ipp64fc:
        {
            *sizeof_datatype = sizeof(Ipp64fc);
            break;
        }
        default:
        {
            status = ippStsDataTypeErr;
        }
    }
    return status;
}


////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeGetSize_<mode> function, where <mode> is:
//    8u, 16u, 16s or 32f.
//
//    Note: currently ipp64f is not supported. TODO implement this.
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResizeGetSize(
    IppDataType ippDataType,
    IppiSize srcSize,
    IppiSize dstSize,
    IppiInterpolationType interpolation,
    Ipp32u antialiasing,
    int* pSpecSize,
    int* pInitBufSize)
{
    IppStatus status = ippStsNoErr;
    switch (ippDataType)
    {
    #line 890
    case ipp8u:
    {
        status = ippiResizeGetSize_8u(srcSize, dstSize, interpolation,
            antialiasing, pSpecSize, pInitBufSize);
        break;
    }

#line 890
    case ipp16u:
    {
        status = ippiResizeGetSize_16u(srcSize, dstSize, interpolation,
            antialiasing, pSpecSize, pInitBufSize);
        break;
    }

#line 890
    case ipp16s:
    {
        status = ippiResizeGetSize_16s(srcSize, dstSize, interpolation,
            antialiasing, pSpecSize, pInitBufSize);
        break;
    }

#line 890
    case ipp32f:
    {
        status = ippiResizeGetSize_32f(srcSize, dstSize, interpolation,
            antialiasing, pSpecSize, pInitBufSize);
        break;
    }

    /*
    case ipp64f:
    {
        // TODO
        // needs specific pSpecSize initialization
        status = ippiResizeGetSize_64f(srcSize, dstSize, interpolation,
                  antialiasing, pSpecSize, pInitBufSize);
        break;
    }
    */
    default:
    {
        status = ippStsDataTypeErr;
    }
    }
    return status;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeGetBufferSize_<mode> function, where <mode>
//    is: 8u, 16u, 16s or 32f.
//
//    Note: currently ipp64f is not supported. TODO implement this.
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResizeGetBufferSize(
    IppDataType ippDataType,
    const IppiResizeSpec_32f* pSpec,
    IppiSize dstSize,
    Ipp32u numChannels,
    int* pBufSize)
{
    IppStatus status = ippStsNoErr;

    switch (ippDataType)
    {

    #line 940
    case ipp8u:
    {
        status = ippiResizeGetBufferSize_8u(pSpec, dstSize,
            numChannels, pBufSize);
        break;
    }

#line 940
    case ipp16u:
    {
        status = ippiResizeGetBufferSize_16u(pSpec, dstSize,
            numChannels, pBufSize);
        break;
    }

#line 940
    case ipp16s:
    {
        status = ippiResizeGetBufferSize_16s(pSpec, dstSize,
            numChannels, pBufSize);
        break;
    }

#line 940
    case ipp32f:
    {
        status = ippiResizeGetBufferSize_32f(pSpec, dstSize,
            numChannels, pBufSize);
        break;
    }

    /*
    // TODO
    pSpec is not 32f
    case ipp64f:
    {
        status = ippiResizeGetBufferSize_64f(pSpec, dstSize, numChannels, pBufSize);
        break;
    }
    */
    default:
    {
        status = ippStsDataTypeErr;
    }
    }
    return status;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeGetSrcRoi_<mode> function, where <mode>
//    is: 8u, 16u, 16s or 32f.
//
//    Note: currently ipp64f is not supported. TODO implement this.
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResizeGetSrcRoi(
    IppDataType ippDataType,
    const IppiResizeSpec_32f* pSpec,
    IppiPoint dstRoiOffset,
    IppiSize dstRoiSize,
    IppiPoint* srcRoiOffset,
    IppiSize* srcRoiSize)
{
    IppStatus status = ippStsNoErr;

    switch (ippDataType)
    {

    #line 990
    case ipp8u:
    {
        status = ippiResizeGetSrcRoi_8u(pSpec, dstRoiOffset,
            dstRoiSize, srcRoiOffset, srcRoiSize);
        break;
    }

#line 990
    case ipp16u:
    {
        status = ippiResizeGetSrcRoi_16u(pSpec, dstRoiOffset,
            dstRoiSize, srcRoiOffset, srcRoiSize);
        break;
    }

#line 990
    case ipp16s:
    {
        status = ippiResizeGetSrcRoi_16s(pSpec, dstRoiOffset,
            dstRoiSize, srcRoiOffset, srcRoiSize);
        break;
    }

#line 990
    case ipp32f:
    {
        status = ippiResizeGetSrcRoi_32f(pSpec, dstRoiOffset,
            dstRoiSize, srcRoiOffset, srcRoiSize);
        break;
    }

    /*
    // TODO
    pSpec is not 32f
    case ipp64f:
    {
        status = ippiResizeGetSrcRoi_64f(pSpec, dstRoiOffset,dstRoiSize,
                srcRoiOffset, srcRoiSize);
        break;
    }
    */
    default:
    {
        status = ippStsDataTypeErr;
    }
    }
    return status;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeGetBorderSize_<mode> function, where <mode>
//    is: 8u, 16u, 16s or 32f.
//
//    Note: currently ipp64f is not supported. TODO implement this.
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResizeGetBorderSize(
    IppDataType ippDataType,
    const IppiResizeSpec_32f* pSpec,
    IppiBorderSize* borderSize)
{
    IppStatus status = ippStsNoErr;

    switch (ippDataType)
    {

    #line 1038
    case ipp8u:
    {
        status = ippiResizeGetBorderSize_8u(pSpec, borderSize);
        break;
    }

#line 1038
    case ipp16u:
    {
        status = ippiResizeGetBorderSize_16u(pSpec, borderSize);
        break;
    }

#line 1038
    case ipp16s:
    {
        status = ippiResizeGetBorderSize_16s(pSpec, borderSize);
        break;
    }

#line 1038
    case ipp32f:
    {
        status = ippiResizeGetBorderSize_32f(pSpec, borderSize);
        break;
    }

    /*
    // TODO
    pSpec is not 32f
    case ipp64f:
    {
        status = ippiResizeGetBorderSize_64f(pSpec, borderSize);
        break;
    }
    */
    default:
    {
        status = ippStsDataTypeErr;
    }
    }
    return status;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeAntialiasing_<mode> function, where <mode>
//    is: 8uC1R, 16uC1R, 16sC1R, 32fC1R, 8uC3R, 16uC3R, 16sC3R or 32fC3R, 8uC4R, 16uC4R,
//    16sC4R or 32fC4R,
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResizeAntialiasing(
    IppDataType ippDataType,
    void * pSrc,
    Ipp32s srcStep,
    void * pDst,
    Ipp32s dstStep,
    IppiPoint dstOffset,
    IppiSize dstSize,
    int numChannels,
    IppiBorderType border,
    void * pBorderValue,
    const IppiResizeSpec_32f* pSpec,
    Ipp8u* pBuffer)
{
    IppStatus status = ippStsNoErr;

    #line 1090
    if (numChannels == 1)
    {
        switch (ippDataType)
        {
            #line 1098
            case ipp8u:
            {
                status = ippiResizeAntialiasing_8u_C1R(pSrc, srcStep, pDst,
                    dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }

#line 1098
            case ipp16u:
            {
                status = ippiResizeAntialiasing_16u_C1R(pSrc, srcStep, pDst,
                    dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }

#line 1098
            case ipp16s:
            {
                status = ippiResizeAntialiasing_16s_C1R(pSrc, srcStep, pDst,
                    dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }

#line 1098
            case ipp32f:
            {
                status = ippiResizeAntialiasing_32f_C1R(pSrc, srcStep, pDst,
                    dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }

            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

#line 1090
    else if (numChannels == 3)
    {
        switch (ippDataType)
        {
            #line 1098
            case ipp8u:
            {
                status = ippiResizeAntialiasing_8u_C3R(pSrc, srcStep, pDst,
                    dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }

#line 1098
            case ipp16u:
            {
                status = ippiResizeAntialiasing_16u_C3R(pSrc, srcStep, pDst,
                    dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }

#line 1098
            case ipp16s:
            {
                status = ippiResizeAntialiasing_16s_C3R(pSrc, srcStep, pDst,
                    dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }

#line 1098
            case ipp32f:
            {
                status = ippiResizeAntialiasing_32f_C3R(pSrc, srcStep, pDst,
                    dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }

            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

#line 1090
    else if (numChannels == 4)
    {
        switch (ippDataType)
        {
            #line 1098
            case ipp8u:
            {
                status = ippiResizeAntialiasing_8u_C4R(pSrc, srcStep, pDst,
                    dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }

#line 1098
            case ipp16u:
            {
                status = ippiResizeAntialiasing_16u_C4R(pSrc, srcStep, pDst,
                    dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }

#line 1098
            case ipp16s:
            {
                status = ippiResizeAntialiasing_16s_C4R(pSrc, srcStep, pDst,
                    dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }

#line 1098
            case ipp32f:
            {
                status = ippiResizeAntialiasing_32f_C4R(pSrc, srcStep, pDst,
                    dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }

            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

    else
    {
        status = ippStsErr;
    }
    return status;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeNearest, ippiResizeLinear, ippiResizeCubic,
//    ippiResizeLanczos and ippiResizeSuper functions.
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResize(IppDataType ippDataType,
    void * pSrc,
    Ipp32s srcStep,
    void * pDst,
    Ipp32s dstStep,
    IppiPoint dstOffset,
    IppiSize dstSize,
    int numChannels,
    IppiBorderType border,
    void * pBorderValue,
    IppiInterpolationType interpolation,
    const IppiResizeSpec_32f* pSpec,
    Ipp8u* pBuffer)
{
    IppStatus status = ippStsNoErr;
    switch (interpolation)
    {
    case ippNearest:
    {
        status = ippiResizeNearest(ippDataType, pSrc, srcStep, pDst, dstStep,
            dstOffset, dstSize, numChannels, pSpec, pBuffer);
        break;
    }
    case ippLinear:
    {
        status = ippiResizeLinear(ippDataType, pSrc, srcStep, pDst, dstStep,
            dstOffset, dstSize, numChannels, border, pBorderValue, pSpec, pBuffer);
        break;
    }
    case ippCubic:
    {
        status = ippiResizeCubic(ippDataType, pSrc, srcStep, pDst, dstStep,
            dstOffset, dstSize, numChannels, border, pBorderValue, pSpec, pBuffer);
        break;
    }
    case ippLanczos:
    {
        status = ippiResizeLanczos(ippDataType, pSrc, srcStep, pDst, dstStep,
            dstOffset, dstSize, numChannels, border, pBorderValue, pSpec, pBuffer);
        break;
    }
    case ippSuper:
    {
        status = ippiResizeSuper(ippDataType, pSrc, srcStep, pDst, dstStep,
            dstOffset, dstSize, numChannels, pSpec, pBuffer);
        break;
    }
    default:
    {
        status = ippStsInterpolationErr;
    }
    }
    return status;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeNearest_<mode> functions, where <mode> is
//    8uC1R, 16uC1R, 16sC1R, 32fC1R, 8uC3R, 16uC3R, 16sC3R or 32fC3R, 8uC4R, 16uC4R,
//    16sC4R or 32fC4R.
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResizeNearest(IppDataType ippDataType,
    void * pSrc,
    Ipp32s srcStep,
    void * pDst,
    Ipp32s dstStep,
    IppiPoint dstOffset,
    IppiSize dstSize,
    int numChannels,
    const IppiResizeSpec_32f* pSpec,
    Ipp8u* pBuffer)
{
    // adapter for: ippiResizeNearest_<mod>,
    // where <mode> is ...
    IppStatus status = ippStsNoErr;

    #line 1209
    if (numChannels == 1)
    {
        switch (ippDataType)
        {
            #line 1217
            case ipp8u:
            {
                status = ippiResizeNearest_8u_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1217
            case ipp16u:
            {
                status = ippiResizeNearest_16u_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1217
            case ipp16s:
            {
                status = ippiResizeNearest_16s_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1217
            case ipp32f:
            {
                status = ippiResizeNearest_32f_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

#line 1209
    else if (numChannels == 3)
    {
        switch (ippDataType)
        {
            #line 1217
            case ipp8u:
            {
                status = ippiResizeNearest_8u_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1217
            case ipp16u:
            {
                status = ippiResizeNearest_16u_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1217
            case ipp16s:
            {
                status = ippiResizeNearest_16s_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1217
            case ipp32f:
            {
                status = ippiResizeNearest_32f_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

#line 1209
    else if (numChannels == 4)
    {
        switch (ippDataType)
        {
            #line 1217
            case ipp8u:
            {
                status = ippiResizeNearest_8u_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1217
            case ipp16u:
            {
                status = ippiResizeNearest_16u_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1217
            case ipp16s:
            {
                status = ippiResizeNearest_16s_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1217
            case ipp32f:
            {
                status = ippiResizeNearest_32f_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

    else
    {
        status = ippStsErr;
    }
    return status;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeLinear_<mode> functions, where <mode> is
//    8uC1R, 16uC1R, 16sC1R, 32fC1R, 8uC3R, 16uC3R, 16sC3R or 32fC3R, 8uC4R, 16uC4R,
//    16sC4R or 32fC4R.
//
//    Note: currently ipp64f is not supported. TODO implement this.
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResizeLinear(IppDataType ippDataType,
    void * pSrc,
    Ipp32s srcStep,
    void * pDst,
    Ipp32s dstStep,
    IppiPoint dstOffset,
    IppiSize dstSize,
    int numChannels,
    IppiBorderType border,
    void * pBorderValue,               // TODO
    const IppiResizeSpec_32f* pSpec,
    Ipp8u* pBuffer)
{
    // adapter for: ippiResizeLinear_<mod>,
    // where <mode> is ...
    IppStatus status = ippStsNoErr;

    #line 1270
    if (numChannels == 1)
    {
        switch (ippDataType)
        {
            #line 1278
            case ipp8u:
            {
                status = ippiResizeLinear_8u_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border,0, pSpec, pBuffer);
            break;
            }

#line 1278
            case ipp16u:
            {
                status = ippiResizeLinear_16u_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border,0, pSpec, pBuffer);
            break;
            }

#line 1278
            case ipp16s:
            {
                status = ippiResizeLinear_16s_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border,0, pSpec, pBuffer);
            break;
            }

#line 1278
            case ipp32f:
            {
                status = ippiResizeLinear_32f_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border,0, pSpec, pBuffer);
            break;
            }


            /*
            * TODO:
            * adding ippiResizeLinear_64f_C<number_of_channels>R
            *
            */
            /*
            case ipp64f:
            {
                status = ippiResizeLinear_64f_C1R(pSrc, srcStep, pDst,
                dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }
            */
            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

#line 1270
    else if (numChannels == 3)
    {
        switch (ippDataType)
        {
            #line 1278
            case ipp8u:
            {
                status = ippiResizeLinear_8u_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border,0, pSpec, pBuffer);
            break;
            }

#line 1278
            case ipp16u:
            {
                status = ippiResizeLinear_16u_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border,0, pSpec, pBuffer);
            break;
            }

#line 1278
            case ipp16s:
            {
                status = ippiResizeLinear_16s_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border,0, pSpec, pBuffer);
            break;
            }

#line 1278
            case ipp32f:
            {
                status = ippiResizeLinear_32f_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border,0, pSpec, pBuffer);
            break;
            }


            /*
            * TODO:
            * adding ippiResizeLinear_64f_C<number_of_channels>R
            *
            */
            /*
            case ipp64f:
            {
                status = ippiResizeLinear_64f_C3R(pSrc, srcStep, pDst,
                dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }
            */
            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

#line 1270
    else if (numChannels == 4)
    {
        switch (ippDataType)
        {
            #line 1278
            case ipp8u:
            {
                status = ippiResizeLinear_8u_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border,0, pSpec, pBuffer);
            break;
            }

#line 1278
            case ipp16u:
            {
                status = ippiResizeLinear_16u_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border,0, pSpec, pBuffer);
            break;
            }

#line 1278
            case ipp16s:
            {
                status = ippiResizeLinear_16s_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border,0, pSpec, pBuffer);
            break;
            }

#line 1278
            case ipp32f:
            {
                status = ippiResizeLinear_32f_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border,0, pSpec, pBuffer);
            break;
            }


            /*
            * TODO:
            * adding ippiResizeLinear_64f_C<number_of_channels>R
            *
            */
            /*
            case ipp64f:
            {
                status = ippiResizeLinear_64f_C4R(pSrc, srcStep, pDst,
                dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
                break;
            }
            */
            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

    else
    {
        status = ippStsErr;
    }
    return status;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeCubic_<mode> functions, where <mode> is
//    8uC1R, 16uC1R, 16sC1R, 32fC1R, 8uC3R, 16uC3R, 16sC3R or 32fC3R, 8uC4R, 16uC4R,
//    16sC4R or 32fC4R.
//
//    Note: currently ipp64f is not supported. TODO implement this.
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResizeCubic(IppDataType ippDataType,
    void * pSrc,
    Ipp32s srcStep,
    void * pDst,
    Ipp32s dstStep,
    IppiPoint dstOffset,
    IppiSize dstSize,
    int numChannels,
    IppiBorderType border,
    void * pBorderValue,               // TODO
    const IppiResizeSpec_32f* pSpec,
    Ipp8u* pBuffer)
{
    // adapter for: ippiResizeCubic_<mod>,
    // where <mode> is ...
    IppStatus status = ippStsNoErr;

    #line 1345
    if (numChannels == 1)
    {
        switch (ippDataType)
        {
            #line 1353
            case ipp8u:
            {
                status = ippiResizeCubic_8u_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1353
            case ipp16u:
            {
                status = ippiResizeCubic_16u_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1353
            case ipp16s:
            {
                status = ippiResizeCubic_16s_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1353
            case ipp32f:
            {
                status = ippiResizeCubic_32f_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }


            /*
            * TODO:
            * adding ippiResizeCubic_64f_C<number_of_channels>R
            *
            */
            /*
            case ipp64f:
            {
                status = ippiResizeCubic_64f_C1R(pSrc, srcStep,
                pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            }
            */
            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

#line 1345
    else if (numChannels == 3)
    {
        switch (ippDataType)
        {
            #line 1353
            case ipp8u:
            {
                status = ippiResizeCubic_8u_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1353
            case ipp16u:
            {
                status = ippiResizeCubic_16u_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1353
            case ipp16s:
            {
                status = ippiResizeCubic_16s_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1353
            case ipp32f:
            {
                status = ippiResizeCubic_32f_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }


            /*
            * TODO:
            * adding ippiResizeCubic_64f_C<number_of_channels>R
            *
            */
            /*
            case ipp64f:
            {
                status = ippiResizeCubic_64f_C3R(pSrc, srcStep,
                pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            }
            */
            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

#line 1345
    else if (numChannels == 4)
    {
        switch (ippDataType)
        {
            #line 1353
            case ipp8u:
            {
                status = ippiResizeCubic_8u_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1353
            case ipp16u:
            {
                status = ippiResizeCubic_16u_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1353
            case ipp16s:
            {
                status = ippiResizeCubic_16s_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1353
            case ipp32f:
            {
                status = ippiResizeCubic_32f_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }


            /*
            * TODO:
            * adding ippiResizeCubic_64f_C<number_of_channels>R
            *
            */
            /*
            case ipp64f:
            {
                status = ippiResizeCubic_64f_C4R(pSrc, srcStep,
                pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            }
            */
            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

    else
    {
        status = ippStsErr;
    }
    return status;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeLanczos_<mode> functions, where <mode> is
//    8uC1R, 16uC1R, 16sC1R, 32fC1R, 8uC3R, 16uC3R, 16sC3R or 32fC3R, 8uC4R, 16uC4R,
//    16sC4R or 32fC4R.
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResizeLanczos(
    IppDataType ippDataType,
    void * pSrc,
    Ipp32s srcStep,
    void * pDst,
    Ipp32s dstStep,
    IppiPoint dstOffset,
    IppiSize dstSize,
    int numChannels,
    IppiBorderType border,
    void * pBorderValue,               // TODO
    const IppiResizeSpec_32f* pSpec,
    Ipp8u* pBuffer)
{
    // adapter for: ippiResizeLanczos_<mod>,
    // where <mode> is ...
    IppStatus status = ippStsNoErr;

    #line 1418
    if (numChannels == 1)
    {
        switch (ippDataType)
        {
            #line 1426
            case ipp8u:
            {
                status = ippiResizeLanczos_8u_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1426
            case ipp16u:
            {
                status = ippiResizeLanczos_16u_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1426
            case ipp16s:
            {
                status = ippiResizeLanczos_16s_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1426
            case ipp32f:
            {
                status = ippiResizeLanczos_32f_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

#line 1418
    else if (numChannels == 3)
    {
        switch (ippDataType)
        {
            #line 1426
            case ipp8u:
            {
                status = ippiResizeLanczos_8u_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1426
            case ipp16u:
            {
                status = ippiResizeLanczos_16u_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1426
            case ipp16s:
            {
                status = ippiResizeLanczos_16s_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1426
            case ipp32f:
            {
                status = ippiResizeLanczos_32f_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

#line 1418
    else if (numChannels == 4)
    {
        switch (ippDataType)
        {
            #line 1426
            case ipp8u:
            {
                status = ippiResizeLanczos_8u_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1426
            case ipp16u:
            {
                status = ippiResizeLanczos_16u_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1426
            case ipp16s:
            {
                status = ippiResizeLanczos_16s_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

#line 1426
            case ipp32f:
            {
                status = ippiResizeLanczos_32f_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, border, 0, pSpec, pBuffer);
            break;
            }

            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

    else
    {
        status = ippStsErr;
    }
    return status;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeSuperInit_<mode> functions, where <mode> is
//    8uC1R, 16uC1R, 16sC1R, 32fC1R, 8uC3R, 16uC3R, 16sC3R or 32fC3R, 8uC4R, 16uC4R,
//    16sC4R or 32fC4R.
//
////////////////////////////////////////////////////////////////////////////////////////

IppStatus
ippiResizeSuper(
    IppDataType ippDataType,
    void * pSrc,
    Ipp32s srcStep,
    void * pDst,
    Ipp32s dstStep,
    IppiPoint dstOffset,
    IppiSize dstSize,
    int numChannels,
    const IppiResizeSpec_32f* pSpec,
    Ipp8u* pBuffer)
{
    // adapter for: ippiResizeNearest_<mod>,
    // where <mode> is ...
    IppStatus status = ippStsNoErr;

    #line 1477
    if (numChannels == 1)
    {
        switch (ippDataType)
        {
            #line 1485
            case ipp8u:
            {
                status = ippiResizeSuper_8u_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1485
            case ipp16u:
            {
                status = ippiResizeSuper_16u_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1485
            case ipp16s:
            {
                status = ippiResizeSuper_16s_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1485
            case ipp32f:
            {
                status = ippiResizeSuper_32f_C1R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

#line 1477
    else if (numChannels == 3)
    {
        switch (ippDataType)
        {
            #line 1485
            case ipp8u:
            {
                status = ippiResizeSuper_8u_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1485
            case ipp16u:
            {
                status = ippiResizeSuper_16u_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1485
            case ipp16s:
            {
                status = ippiResizeSuper_16s_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1485
            case ipp32f:
            {
                status = ippiResizeSuper_32f_C3R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

#line 1477
    else if (numChannels == 4)
    {
        switch (ippDataType)
        {
            #line 1485
            case ipp8u:
            {
                status = ippiResizeSuper_8u_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1485
            case ipp16u:
            {
                status = ippiResizeSuper_16u_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1485
            case ipp16s:
            {
                status = ippiResizeSuper_16s_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

#line 1485
            case ipp32f:
            {
                status = ippiResizeSuper_32f_C4R(pSrc, srcStep,
                    pDst, dstStep, dstOffset, dstSize, pSpec, pBuffer);
            break;
            }

            default:
            {
                status = ippStsDataTypeErr;
            }
        }
    }

    else
    {
        status = ippStsErr;
    }
    return status;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeNearestInit_<mode> functions, where <mode>
//    is: 8u, 16u, 16s or 32f.
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResizeNearestInit(
    IppDataType ippDataType,
    IppiSize srcSize,
    IppiSize dstSize,
    IppiResizeSpec_32f* pSpec)
{
    IppStatus status = ippStsNoErr;

    switch (ippDataType)
    {

    #line 1528
    case ipp8u:
    {
        status = ippiResizeNearestInit_8u(srcSize, dstSize, pSpec);
        break;
    }

#line 1528
    case ipp16u:
    {
        status = ippiResizeNearestInit_16u(srcSize, dstSize, pSpec);
        break;
    }

#line 1528
    case ipp16s:
    {
        status = ippiResizeNearestInit_16s(srcSize, dstSize, pSpec);
        break;
    }

#line 1528
    case ipp32f:
    {
        status = ippiResizeNearestInit_32f(srcSize, dstSize, pSpec);
        break;
    }

    default:
    {
        status = ippStsDataTypeErr;
    }
    }
    return status;

}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeLinearInit_<mode> functions, where <mode>
//    is: 8u, 16u, 16s or 32f.
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResizeLinearInit(
    IppDataType ippDataType,
    IppiSize srcSize,
    IppiSize dstSize,
    IppiResizeSpec_32f* pSpec)
{
    IppStatus status = ippStsNoErr;

    switch (ippDataType)
    {

    #line 1565
    case ipp8u:
    {
        status = ippiResizeLinearInit_8u(srcSize, dstSize, pSpec);
        break;
    }

#line 1565
    case ipp16u:
    {
        status = ippiResizeLinearInit_16u(srcSize, dstSize, pSpec);
        break;
    }

#line 1565
    case ipp16s:
    {
        status = ippiResizeLinearInit_16s(srcSize, dstSize, pSpec);
        break;
    }

#line 1565
    case ipp32f:
    {
        status = ippiResizeLinearInit_32f(srcSize, dstSize, pSpec);
        break;
    }

    /*
     * TODO:
     * 64f
    case ipp64f:
    {
        status = ippiResizeLinearInit_64f(srcSize, dstSize, pSpec);
        break;
    }
    */
    default:
    {
        status = ippStsDataTypeErr;
    }
    }
    return status;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeLanczosInit_<mode> functions, where <mode>
//    is: 8u, 16u, 16s or 32f.
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResizeLanczosInit(
    IppDataType ippDataType,
    IppiSize srcSize,
    IppiSize dstSize,
    Ipp32u numLobes,
    IppiResizeSpec_32f* pSpec,
    Ipp8u* pInitBuf)
{
    IppStatus status = ippStsNoErr;

    switch (ippDataType)
    {
    #line 1611
    case ipp8u:
    {
        status = ippiResizeLanczosInit_8u(srcSize, dstSize, numLobes,
            pSpec, pInitBuf);
        break;
    }

#line 1611
    case ipp16u:
    {
        status = ippiResizeLanczosInit_16u(srcSize, dstSize, numLobes,
            pSpec, pInitBuf);
        break;
    }

#line 1611
    case ipp16s:
    {
        status = ippiResizeLanczosInit_16s(srcSize, dstSize, numLobes,
            pSpec, pInitBuf);
        break;
    }

#line 1611
    case ipp32f:
    {
        status = ippiResizeLanczosInit_32f(srcSize, dstSize, numLobes,
            pSpec, pInitBuf);
        break;
    }

    default:
    {
        status = ippStsDataTypeErr;
    }
    }
    return status;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeCubicInit_<mode> functions, where <mode>
//    is: 8u, 16u, 16s or 32f.
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResizeCubicInit(
    IppDataType ippDataType,
    IppiSize srcSize,
    IppiSize dstSize,
    Ipp32f valueB,
    Ipp32f valueC,
    IppiResizeSpec_32f* pSpec,
    Ipp8u* pInitBuf)
{
    IppStatus status = ippStsNoErr;

    switch (ippDataType)
    {
    #line 1650
    case ipp8u:
    {
        status = ippiResizeCubicInit_8u(srcSize, dstSize, valueB, valueC,
            pSpec, pInitBuf);
        break;
    }

#line 1650
    case ipp16u:
    {
        status = ippiResizeCubicInit_16u(srcSize, dstSize, valueB, valueC,
            pSpec, pInitBuf);
        break;
    }

#line 1650
    case ipp16s:
    {
        status = ippiResizeCubicInit_16s(srcSize, dstSize, valueB, valueC,
            pSpec, pInitBuf);
        break;
    }

#line 1650
    case ipp32f:
    {
        status = ippiResizeCubicInit_32f(srcSize, dstSize, valueB, valueC,
            pSpec, pInitBuf);
        break;
    }

    default:
    {
        status = ippStsDataTypeErr;
    }
    }
    return status;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//    Adapter for ippiResizeSuperInit_<mode> functions, where <mode>
//    is: 8u, 16u, 16s or 32f.
//
////////////////////////////////////////////////////////////////////////////////////////
IppStatus
ippiResizeSuperInit(
    IppDataType ippDataType,
    IppiSize srcSize,
    IppiSize dstSize,
    IppiResizeSpec_32f* pSpec)
{
    IppStatus status = ippStsNoErr;

    switch (ippDataType)
    {

    #line 1687
    case ipp8u:
    {
        status = ippiResizeSuperInit_8u(srcSize, dstSize, pSpec);
        break;
    }

#line 1687
    case ipp16u:
    {
        status = ippiResizeSuperInit_16u(srcSize, dstSize, pSpec);
        break;
    }

#line 1687
    case ipp16s:
    {
        status = ippiResizeSuperInit_16s(srcSize, dstSize, pSpec);
        break;
    }

#line 1687
    case ipp32f:
    {
        status = ippiResizeSuperInit_32f(srcSize, dstSize, pSpec);
        break;
    }

    default:
    {
        status = ippStsDataTypeErr;
    }
    }
    return status;
}

